/**
 * RTOS Access Control Sample Program
 *
 * This program shows "ABCDEFG TASK1" and "GFEDCBA TASK2".
 * These message are generated by user_task1 and user_task2 and shown by cyclic task.
 * Some valuables are used for sharing the message between user tasks and cyclic task.
 *
 * Written by Yasuhiro Noguchi
 * Email: yasuhiro.noguchi@gmail.com
 */

#include <string.h>

#include "ev3api.h"
#include "app.h"

// 利用するAPIのヘッダファイル
#include "LCD.h"
#include "Clock.h"

// EV3APIの名前空間
using namespace ev3api;

// EV3APIのオブジェクト
auto clock = new Clock();
auto lcd = new LCD();

// 共有出力バッファ
#define BUFFERSIZE 64
char outputBuffer[BUFFERSIZE];
bool_t outputBufferSet = false;

void wait(uint32_t duration) {
	uint32_t base = clock->now();
	while ( base + duration > clock->now() );
	return;
}

// OUTPUT_CYC_HANDLER defined in app.cfg
int16_t timesOuputCycHandler = 0;
void output_cyc_handler(intptr_t unused) {
	char str[64] = "";
	char buf[BUFFERSIZE] = "";
	lcd->setFont(EV3_FONT_MEDIUM);

	// output message for confirming this cyclic handler is running.
	snprintf(str, 64, "CYC_HANDLER: %d", timesOuputCycHandler++);
	lcd->drawString(str, 0, lcd->getCurrentFontHeight());

	// セマフォの状態表示: 待ち行列の1番目のタスクID, 資源の残り数
	T_RSEM semInfo;
	ref_sem(SEM_OUTPUTBUFFER, &semInfo);
	snprintf(str, 64, "SEM: id: %d", semInfo.wtskid);
	lcd->drawString(str, 0, lcd->getCurrentFontHeight()*2);
	snprintf(str, 64, "SEM: cnt: %d", semInfo.semcnt);
	lcd->drawString(str, 0, lcd->getCurrentFontHeight()*3);
	snprintf(str, 64, "TASKID(1): %d", USER_TASK1);
	lcd->drawString(str, 0, lcd->getCurrentFontHeight()*4);
	snprintf(str, 64, "TASKID(2): %d", USER_TASK2);
	lcd->drawString(str, 0, lcd->getCurrentFontHeight()*5);

	// output buffer set by other task
	if (outputBufferSet == true) {
		strncpy(buf, outputBuffer, BUFFERSIZE);
		outputBufferSet = false;
		lcd->drawString(buf, 0, 0);
	}
}

// TASK defined in app.cfg
void user_task1(intptr_t unused) {
	const char msg[] = "ABCDEFG TASK1";
	int16_t msgLength = strlen(msg);

	while (true) {
		while ( outputBufferSet == true ) {
			clock->wait(1000);
		}

		// セマフォを使わない場合(wai_sem, sig_semを使わない)の挙動を確認せよ。
		wai_sem(SEM_OUTPUTBUFFER);
		if ( outputBufferSet == true ) {
			sig_sem(SEM_OUTPUTBUFFER);	// コメントアウトした場合の挙動を確認せよ。
			continue;
		}

		int16_t pos = 0;
		while (pos < msgLength) {
			// 恣意的に時間をかけてメッセージ文字列を生成
			outputBuffer[pos] = msg[pos];
			outputBuffer[pos + 1] = '\0';
			pos++;
			clock->wait(200);
		}
		outputBufferSet = true;
		sig_sem(SEM_OUTPUTBUFFER);
		/////////////////////////////////////
		clock->wait(1000);
	}
}

// TASK defined in app.cfg
void user_task2(intptr_t unused) {
	const char msg[] = "GFEDCBA TASK2";
	int16_t msgLength = strlen(msg);

	while (true) {
		if ( outputBufferSet == true ) {
			clock->wait(1000);
		}

		// セマフォを使わない場合(wai_sem, sig_semを使わない)の挙動を確認せよ。
		wai_sem(SEM_OUTPUTBUFFER);
		if ( outputBufferSet == true ) {
			sig_sem(SEM_OUTPUTBUFFER);
			continue;
		}

		int16_t pos = 0;
		while (pos < msgLength) {
			// 恣意的に時間をかけてメッセージ文字列を生成
			outputBuffer[pos] = msg[pos];
			outputBuffer[pos + 1] = '\0';
			pos++;
			clock->wait(200);
		}
		outputBufferSet = true;
		sig_sem(SEM_OUTPUTBUFFER);
		/////////////////////////////////////
		clock->wait(1000);
	}
}
